'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.pointVisConfigs = exports.pointOptionalColumns = exports.pointRequiredColumns = exports.pointPosResolver = exports.pointPosAccessor = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _baseLayer = require('../base-layer');

var _baseLayer2 = _interopRequireDefault(_baseLayer);

var _lodash = require('lodash.memoize');

var _lodash2 = _interopRequireDefault(_lodash);

var _deck = require('deck.gl');

var _scatterplotBrushingLayer = require('../../deckgl-layers/scatterplot-brushing-layer/scatterplot-brushing-layer');

var _scatterplotBrushingLayer2 = _interopRequireDefault(_scatterplotBrushingLayer);

var _colorUtils = require('../../utils/color-utils');

var _pointLayerIcon = require('./point-layer-icon');

var _pointLayerIcon2 = _interopRequireDefault(_pointLayerIcon);

var _defaultSettings = require('../../constants/default-settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pointPosAccessor = exports.pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng,
      altitude = _ref.altitude;
  return function (d) {
    return [d.data[lng.fieldIdx], d.data[lat.fieldIdx], altitude && altitude.fieldIdx > -1 ? d.data[altitude.fieldIdx] : 0];
  };
}; // Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var pointPosResolver = exports.pointPosResolver = function pointPosResolver(_ref2) {
  var lat = _ref2.lat,
      lng = _ref2.lng,
      altitude = _ref2.altitude;
  return lat.fieldIdx + '-' + lng.fieldIdx + '-' + (altitude ? altitude.fieldIdx : 'z');
};
var pointRequiredColumns = exports.pointRequiredColumns = ['lat', 'lng'];
var pointOptionalColumns = exports.pointOptionalColumns = ['altitude'];

var pointVisConfigs = exports.pointVisConfigs = {
  radius: 'radius',
  fixedRadius: 'fixedRadius',
  opacity: 'opacity',
  outline: 'outline',
  thickness: 'thickness',
  colorRange: 'colorRange',
  radiusRange: 'radiusRange',
  'hi-precision': 'hi-precision'
};

var PointLayer = function (_Layer) {
  (0, _inherits3.default)(PointLayer, _Layer);

  function PointLayer(props) {
    (0, _classCallCheck3.default)(this, PointLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PointLayer.__proto__ || Object.getPrototypeOf(PointLayer)).call(this, props));

    _this.registerVisConfig(pointVisConfigs);
    _this.getPosition = (0, _lodash2.default)(pointPosAccessor, pointPosResolver);
    return _this;
  }

  (0, _createClass3.default)(PointLayer, [{
    key: 'formatLayerData',
    value: function formatLayerData(_, allData, filteredIndex, oldLayerData) {
      var _this2 = this;

      var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var _config = this.config,
          colorScale = _config.colorScale,
          colorDomain = _config.colorDomain,
          colorField = _config.colorField,
          color = _config.color,
          columns = _config.columns,
          sizeField = _config.sizeField,
          sizeScale = _config.sizeScale,
          sizeDomain = _config.sizeDomain,
          _config$visConfig = _config.visConfig,
          radiusRange = _config$visConfig.radiusRange,
          fixedRadius = _config$visConfig.fixedRadius,
          colorRange = _config$visConfig.colorRange;

      // point color

      var cScale = colorField && this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_colorUtils.hexToRgb));

      // point radius
      var rScale = sizeField && this.getVisChannelScale(sizeScale, sizeDomain, radiusRange, fixedRadius);

      var getPosition = this.getPosition(columns);

      if (!oldLayerData || oldLayerData.getPosition !== getPosition) {
        this.updateLayerMeta(allData, getPosition);
      }

      var data = void 0;
      if (oldLayerData && oldLayerData.data && opt.sameData && oldLayerData.getPosition === getPosition) {
        data = oldLayerData.data;
      } else {
        data = filteredIndex.reduce(function (accu, index) {
          var pos = getPosition({ data: allData[index] });

          // if doesn't have point lat or lng, do not add the point
          // deck.gl can't handle position = null
          if (!pos.every(Number.isFinite)) {
            return accu;
          }

          accu.push({
            data: allData[index]
          });

          return accu;
        }, []);
      }

      var getRadius = rScale ? function (d) {
        return _this2.getEncodedChannelValue(rScale, d.data, sizeField);
      } : 1;

      var getColor = cScale ? function (d) {
        return _this2.getEncodedChannelValue(cScale, d.data, colorField);
      } : color;

      return {
        data: data,
        getPosition: getPosition,
        getColor: getColor,
        getRadius: getRadius
      };
    }
  }, {
    key: 'updateLayerMeta',
    value: function updateLayerMeta(allData, getPosition) {
      var bounds = this.getPointsBounds(allData, function (d) {
        return getPosition({ data: d });
      });
      this.updateMeta({ bounds: bounds });
    }
  }, {
    key: 'renderLayer',
    value: function renderLayer(_ref3) {
      var _this3 = this;

      var data = _ref3.data,
          idx = _ref3.idx,
          layerInteraction = _ref3.layerInteraction,
          objectHovered = _ref3.objectHovered,
          mapState = _ref3.mapState,
          interactionConfig = _ref3.interactionConfig;

      var enableBrushing = interactionConfig.brush.enabled;

      var layerProps = (0, _extends3.default)({
        outline: this.config.visConfig.outline,
        radiusMinPixels: 1,
        fp64: this.config.visConfig['hi-precision'],
        strokeWidth: this.config.visConfig.thickness,
        radiusScale: this.getRadiusScaleByZoom(mapState)
      }, this.config.visConfig.fixedRadius ? {} : { radiusMaxPixels: 500 });

      var interaction = {
        autoHighlight: !enableBrushing,
        enableBrushing: enableBrushing,
        brushRadius: interactionConfig.brush.config.size * 1000,
        highlightColor: this.config.highlightColor
      };

      return [new _scatterplotBrushingLayer2.default((0, _extends3.default)({}, layerProps, layerInteraction, data, interaction, {
        idx: idx,
        id: this.id,
        opacity: this.config.visConfig.opacity,
        pickable: true,
        parameters: {
          // circles will be flat on the map when the altitude column is not used
          depthTest: this.config.columns.altitude.fieldIdx > -1
        },

        updateTriggers: {
          getRadius: {
            sizeField: this.config.sizeField,
            radiusRange: this.config.visConfig.radiusRange,
            fixedRadius: this.config.visConfig.fixedRadius,
            sizeScale: this.config.sizeScale
          },
          getColor: {
            color: this.config.color,
            colorField: this.config.colorField,
            colorRange: this.config.visConfig.colorRange,
            colorScale: this.config.colorScale
          }
        }
      }))].concat((0, _toConsumableArray3.default)(this.config.textLabel.field ? [new _deck.TextLayer({
        id: this.id + '-label',
        data: data.data,
        getPosition: data.getPosition,
        getPixelOffset: this.config.textLabel.offset,
        getSize: this.config.textLabel.size,
        getTextAnchor: this.config.textLabel.anchor,
        getText: function getText(d) {
          return String(d.data[_this3.config.textLabel.field.tableFieldIndex - 1]);
        },
        getColor: function getColor(d) {
          return _this3.config.textLabel.color;
        },
        fp64: this.config.visConfig['hi-precision'],
        parameters: {
          // text will always show on top of all layers
          depthTest: false
        },
        updateTriggers: {
          getPosition: data.getPosition,
          getPixelOffset: this.config.textLabel.offset,
          getText: this.config.textLabel.field,
          getTextAnchor: this.config.textLabel.anchor,
          getSize: this.config.textLabel.size,
          getColor: this.config.textLabel.color
        }
      })] : []));
    }
  }, {
    key: 'type',
    get: function get() {
      return 'point';
    }
  }, {
    key: 'isAggregated',
    get: function get() {
      return false;
    }
  }, {
    key: 'layerIcon',
    get: function get() {
      return _pointLayerIcon2.default;
    }
  }, {
    key: 'requiredLayerColumns',
    get: function get() {
      return pointRequiredColumns;
    }
  }, {
    key: 'optionalColumns',
    get: function get() {
      return pointOptionalColumns;
    }
  }, {
    key: 'columnPairs',
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: 'noneLayerDataAffectingProps',
    get: function get() {
      return [].concat((0, _toConsumableArray3.default)((0, _get3.default)(PointLayer.prototype.__proto__ || Object.getPrototypeOf(PointLayer.prototype), 'noneLayerDataAffectingProps', this)), ['radius']);
    }
  }, {
    key: 'visualChannels',
    get: function get() {
      return (0, _extends3.default)({}, (0, _get3.default)(PointLayer.prototype.__proto__ || Object.getPrototypeOf(PointLayer.prototype), 'visualChannels', this), {
        size: (0, _extends3.default)({}, (0, _get3.default)(PointLayer.prototype.__proto__ || Object.getPrototypeOf(PointLayer.prototype), 'visualChannels', this).size, {
          range: 'radiusRange',
          property: 'radius',
          channelScaleType: 'radius'
        })
      });
    }
  }], [{
    key: 'findDefaultLayerProps',
    value: function findDefaultLayerProps(_ref4) {
      var _ref4$fieldPairs = _ref4.fieldPairs,
          fieldPairs = _ref4$fieldPairs === undefined ? [] : _ref4$fieldPairs;

      var props = [];

      // Make layer for each pair
      fieldPairs.forEach(function (pair) {
        // find fields for tableFieldIndex
        var latField = pair.pair.lat;
        var lngField = pair.pair.lng;
        var layerName = pair.defaultName;

        var prop = {
          label: layerName.length ? layerName : 'Point'
        };

        // default layer color for begintrip and dropoff point
        if (latField.value in _defaultSettings.DEFAULT_LAYER_COLOR) {
          prop.color = (0, _colorUtils.hexToRgb)(_defaultSettings.DEFAULT_LAYER_COLOR[latField.value]);
        }

        // set the first layer to be visible
        if (props.length === 0) {
          prop.isVisible = true;
        }

        // const newLayer = new KeplerGlLayers.PointLayer(prop);
        prop.columns = {
          lat: latField,
          lng: lngField,
          altitude: { value: null, fieldIdx: -1, optional: true }
        };

        props.push(prop);
      });

      return props;
    }
  }]);
  return PointLayer;
}(_baseLayer2.default);

exports.default = PointLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXllcnMvcG9pbnQtbGF5ZXIvcG9pbnQtbGF5ZXIuanMiXSwibmFtZXMiOlsicG9pbnRQb3NBY2Nlc3NvciIsImxhdCIsImxuZyIsImFsdGl0dWRlIiwiZCIsImRhdGEiLCJmaWVsZElkeCIsInBvaW50UG9zUmVzb2x2ZXIiLCJwb2ludFJlcXVpcmVkQ29sdW1ucyIsInBvaW50T3B0aW9uYWxDb2x1bW5zIiwicG9pbnRWaXNDb25maWdzIiwicmFkaXVzIiwiZml4ZWRSYWRpdXMiLCJvcGFjaXR5Iiwib3V0bGluZSIsInRoaWNrbmVzcyIsImNvbG9yUmFuZ2UiLCJyYWRpdXNSYW5nZSIsIlBvaW50TGF5ZXIiLCJwcm9wcyIsInJlZ2lzdGVyVmlzQ29uZmlnIiwiZ2V0UG9zaXRpb24iLCJfIiwiYWxsRGF0YSIsImZpbHRlcmVkSW5kZXgiLCJvbGRMYXllckRhdGEiLCJvcHQiLCJjb25maWciLCJjb2xvclNjYWxlIiwiY29sb3JEb21haW4iLCJjb2xvckZpZWxkIiwiY29sb3IiLCJjb2x1bW5zIiwic2l6ZUZpZWxkIiwic2l6ZVNjYWxlIiwic2l6ZURvbWFpbiIsInZpc0NvbmZpZyIsImNTY2FsZSIsImdldFZpc0NoYW5uZWxTY2FsZSIsImNvbG9ycyIsIm1hcCIsImhleFRvUmdiIiwiclNjYWxlIiwidXBkYXRlTGF5ZXJNZXRhIiwic2FtZURhdGEiLCJyZWR1Y2UiLCJhY2N1IiwiaW5kZXgiLCJwb3MiLCJldmVyeSIsIk51bWJlciIsImlzRmluaXRlIiwicHVzaCIsImdldFJhZGl1cyIsImdldEVuY29kZWRDaGFubmVsVmFsdWUiLCJnZXRDb2xvciIsImJvdW5kcyIsImdldFBvaW50c0JvdW5kcyIsInVwZGF0ZU1ldGEiLCJpZHgiLCJsYXllckludGVyYWN0aW9uIiwib2JqZWN0SG92ZXJlZCIsIm1hcFN0YXRlIiwiaW50ZXJhY3Rpb25Db25maWciLCJlbmFibGVCcnVzaGluZyIsImJydXNoIiwiZW5hYmxlZCIsImxheWVyUHJvcHMiLCJyYWRpdXNNaW5QaXhlbHMiLCJmcDY0Iiwic3Ryb2tlV2lkdGgiLCJyYWRpdXNTY2FsZSIsImdldFJhZGl1c1NjYWxlQnlab29tIiwicmFkaXVzTWF4UGl4ZWxzIiwiaW50ZXJhY3Rpb24iLCJhdXRvSGlnaGxpZ2h0IiwiYnJ1c2hSYWRpdXMiLCJzaXplIiwiaGlnaGxpZ2h0Q29sb3IiLCJTY2F0dGVycGxvdEJydXNoaW5nTGF5ZXIiLCJpZCIsInBpY2thYmxlIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsInVwZGF0ZVRyaWdnZXJzIiwidGV4dExhYmVsIiwiZmllbGQiLCJUZXh0TGF5ZXIiLCJnZXRQaXhlbE9mZnNldCIsIm9mZnNldCIsImdldFNpemUiLCJnZXRUZXh0QW5jaG9yIiwiYW5jaG9yIiwiZ2V0VGV4dCIsIlN0cmluZyIsInRhYmxlRmllbGRJbmRleCIsIlBvaW50TGF5ZXJJY29uIiwiZGVmYXVsdFBvaW50Q29sdW1uUGFpcnMiLCJyYW5nZSIsInByb3BlcnR5IiwiY2hhbm5lbFNjYWxlVHlwZSIsImZpZWxkUGFpcnMiLCJmb3JFYWNoIiwibGF0RmllbGQiLCJwYWlyIiwibG5nRmllbGQiLCJsYXllck5hbWUiLCJkZWZhdWx0TmFtZSIsInByb3AiLCJsYWJlbCIsImxlbmd0aCIsInZhbHVlIiwiREVGQVVMVF9MQVlFUl9DT0xPUiIsImlzVmlzaWJsZSIsIm9wdGlvbmFsIiwiTGF5ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFFTyxJQUFNQSw4Q0FBbUIsU0FBbkJBLGdCQUFtQjtBQUFBLE1BQUVDLEdBQUYsUUFBRUEsR0FBRjtBQUFBLE1BQU9DLEdBQVAsUUFBT0EsR0FBUDtBQUFBLE1BQVlDLFFBQVosUUFBWUEsUUFBWjtBQUFBLFNBQTBCO0FBQUEsV0FBSyxDQUM3REMsRUFBRUMsSUFBRixDQUFPSCxJQUFJSSxRQUFYLENBRDZELEVB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UTtBQUN6QjtBQUNBLFlBQU1DLFdBQVdDLEtBQUtBLElBQUwsQ0FBVXZHLEdBQTNCO0FBQ0EsWUFBTXdHLFdBQVdELEtBQUtBLElBQUwsQ0FBVXRHLEdBQTNCO0FBQ0EsWUFBTXdHLFlBQVlGLEtBQUtHLFdBQXZCOztBQUVBLFlBQU1DLE9BQU87QUFDWEMsaUJBQU9ILFVBQVVJLE1BQVYsR0FBbUJKLFNBQW5CLEdBQStCO0FBRDNCLFNBQWI7O0FBSUE7QUFDQSxZQUFJSCxTQUFTUSxLQUFULElBQWtCQyxvQ0FBdEIsRUFBMkM7QUFDekNKLGVBQUs3RSxLQUFMLEdBQWEsMEJBQVNpRixxQ0FBb0JULFNBQVNRLEtBQTdCLENBQVQsQ0FBYjtBQUNEOztBQUVEO0FBQ0EsWUFBSTVGLE1BQU0yRixNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCRixlQUFLSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0Q7O0FBRUQ7QUFDQUwsYUFBSzVFLE9BQUwsR0FBZTtBQUNiL0IsZUFBS3NHLFFBRFE7QUFFYnJHLGVBQUt1RyxRQUZRO0FBR2J0RyxvQkFBVSxFQUFDNEcsT0FBTyxJQUFSLEVBQWN6RyxVQUFVLENBQUMsQ0FBekIsRUFBNEI0RyxVQUFVLElBQXRDO0FBSEcsU0FBZjs7QUFNQS9GLGNBQU1pQyxJQUFOLENBQVd3RCxJQUFYO0FBQ0QsT0E1QkQ7O0FBOEJBLGFBQU96RixLQUFQO0FBQ0Q7OztFQWxGcUNnRyxtQjs7a0JBQW5CakcsVSIsImZpbGUiOiJwb2ludC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxOCBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBMYXllciBmcm9tICcuLi9iYXNlLWxheWVyJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcbmltcG9ydCB7VGV4dExheWVyfSBmcm9tICdkZWNrLmdsJztcbmltcG9ydCBTY2F0dGVycGxvdEJydXNoaW5nTGF5ZXIgZnJvbSAnZGVja2dsLWxheWVycy9zY2F0dGVycGxvdC1icnVzaGluZy1sYXllci9zY2F0dGVycGxvdC1icnVzaGluZy1sYXllcic7XG5pbXBvcnQge2hleFRvUmdifSBmcm9tICd1dGlscy9jb2xvci11dGlscyc7XG5pbXBvcnQgUG9pbnRMYXllckljb24gZnJvbSAnLi9wb2ludC1sYXllci1pY29uJztcbmltcG9ydCB7REVGQVVMVF9MQVlFUl9DT0xPUn0gZnJvbSAnY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuXG5leHBvcnQgY29uc3QgcG9pbnRQb3NBY2Nlc3NvciA9ICh7bGF0LCBsbmcsIGFsdGl0dWRlfSkgPT4gZCA9PiBbXG4gIGQuZGF0YVtsbmcuZmllbGRJZHhdLFxuICBkLmRhdGFbbGF0LmZpZWxkSWR4XSxcbiAgYWx0aXR1ZGUgJiYgYWx0aXR1ZGUuZmllbGRJZHggPiAtMSA/IGQuZGF0YVthbHRpdHVkZS5maWVsZElkeF0gOiAwXG5dO1xuXG5leHBvcnQgY29uc3QgcG9pbnRQb3NSZXNvbHZlciA9ICh7bGF0LCBsbmcsIGFsdGl0dWRlfSkgPT5cbiAgYCR7bGF0LmZpZWxkSWR4fS0ke2xuZy5maWVsZElkeH0tJHthbHRpdHVkZSA/IGFsdGl0dWRlLmZpZWxkSWR4IDogJ3onfWA7XG5leHBvcnQgY29uc3QgcG9pbnRSZXF1aXJlZENvbHVtbnMgPSBbJ2xhdCcsICdsbmcnXTtcbmV4cG9ydCBjb25zdCBwb2ludE9wdGlvbmFsQ29sdW1ucyA9IFsnYWx0aXR1ZGUnXTtcblxuZXhwb3J0IGNvbnN0IHBvaW50VmlzQ29uZmlncyA9IHtcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgZml4ZWRSYWRpdXM6ICdmaXhlZFJhZGl1cycsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3V0bGluZTogJ291dGxpbmUnLFxuICB0aGlja25lc3M6ICd0aGlja25lc3MnLFxuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZScsXG4gIHJhZGl1c1JhbmdlOiAncmFkaXVzUmFuZ2UnLFxuICAnaGktcHJlY2lzaW9uJzogJ2hpLXByZWNpc2lvbidcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5yZWdpc3RlclZpc0NvbmZpZyhwb2ludFZpc0NvbmZpZ3MpO1xuICAgIHRoaXMuZ2V0UG9zaXRpb24gPSBtZW1vaXplKHBvaW50UG9zQWNjZXNzb3IsIHBvaW50UG9zUmVzb2x2ZXIpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwb2ludCc7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCBsYXllckljb24oKSB7XG4gICAgcmV0dXJuIFBvaW50TGF5ZXJJY29uO1xuICB9XG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpIHtcbiAgICByZXR1cm4gcG9pbnRSZXF1aXJlZENvbHVtbnM7XG4gIH1cblxuICBnZXQgb3B0aW9uYWxDb2x1bW5zKCkge1xuICAgIHJldHVybiBwb2ludE9wdGlvbmFsQ29sdW1ucztcbiAgfVxuXG4gIGdldCBjb2x1bW5QYWlycygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UG9pbnRDb2x1bW5QYWlycztcbiAgfVxuXG4gIGdldCBub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5ub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMsICdyYWRpdXMnXTtcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIudmlzdWFsQ2hhbm5lbHMsXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnN1cGVyLnZpc3VhbENoYW5uZWxzLnNpemUsXG4gICAgICAgIHJhbmdlOiAncmFkaXVzUmFuZ2UnLFxuICAgICAgICBwcm9wZXJ0eTogJ3JhZGl1cycsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6ICdyYWRpdXMnXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmaW5kRGVmYXVsdExheWVyUHJvcHMoe2ZpZWxkUGFpcnMgPSBbXX0pIHtcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuXG4gICAgLy8gTWFrZSBsYXllciBmb3IgZWFjaCBwYWlyXG4gICAgZmllbGRQYWlycy5mb3JFYWNoKHBhaXIgPT4ge1xuICAgICAgLy8gZmluZCBmaWVsZHMgZm9yIHRhYmxlRmllbGRJbmRleFxuICAgICAgY29uc3QgbGF0RmllbGQgPSBwYWlyLnBhaXIubGF0O1xuICAgICAgY29uc3QgbG5nRmllbGQgPSBwYWlyLnBhaXIubG5nO1xuICAgICAgY29uc3QgbGF5ZXJOYW1lID0gcGFpci5kZWZhdWx0TmFtZTtcblxuICAgICAgY29uc3QgcHJvcCA9IHtcbiAgICAgICAgbGFiZWw6IGxheWVyTmFtZS5sZW5ndGggPyBsYXllck5hbWUgOiAnUG9pbnQnXG4gICAgICB9O1xuXG4gICAgICAvLyBkZWZhdWx0IGxheWVyIGNvbG9yIGZvciBiZWdpbnRyaXAgYW5kIGRyb3BvZmYgcG9pbnRcbiAgICAgIGlmIChsYXRGaWVsZC52YWx1ZSBpbiBERUZBVUxUX0xBWUVSX0NPTE9SKSB7XG4gICAgICAgIHByb3AuY29sb3IgPSBoZXhUb1JnYihERUZBVUxUX0xBWUVSX0NPTE9SW2xhdEZpZWxkLnZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgZmlyc3QgbGF5ZXIgdG8gYmUgdmlzaWJsZVxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwcm9wLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnN0IG5ld0xheWVyID0gbmV3IEtlcGxlckdsTGF5ZXJzLlBvaW50TGF5ZXIocHJvcCk7XG4gICAgICBwcm9wLmNvbHVtbnMgPSB7XG4gICAgICAgIGxhdDogbGF0RmllbGQsXG4gICAgICAgIGxuZzogbG5nRmllbGQsXG4gICAgICAgIGFsdGl0dWRlOiB7dmFsdWU6IG51bGwsIGZpZWxkSWR4OiAtMSwgb3B0aW9uYWw6IHRydWV9XG4gICAgICB9O1xuXG4gICAgICBwcm9wcy5wdXNoKHByb3ApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKF8sIGFsbERhdGEsIGZpbHRlcmVkSW5kZXgsIG9sZExheWVyRGF0YSwgb3B0ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclNjYWxlLFxuICAgICAgY29sb3JEb21haW4sXG4gICAgICBjb2xvckZpZWxkLFxuICAgICAgY29sb3IsXG4gICAgICBjb2x1bW5zLFxuICAgICAgc2l6ZUZpZWxkLFxuICAgICAgc2l6ZVNjYWxlLFxuICAgICAgc2l6ZURvbWFpbixcbiAgICAgIHZpc0NvbmZpZzoge3JhZGl1c1JhbmdlLCBmaXhlZFJhZGl1cywgY29sb3JSYW5nZX1cbiAgICB9ID0gdGhpcy5jb25maWc7XG5cbiAgICAvLyBwb2ludCBjb2xvclxuICAgIGNvbnN0IGNTY2FsZSA9XG4gICAgICBjb2xvckZpZWxkICYmXG4gICAgICB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShcbiAgICAgICAgY29sb3JTY2FsZSxcbiAgICAgICAgY29sb3JEb21haW4sXG4gICAgICAgIGNvbG9yUmFuZ2UuY29sb3JzLm1hcChoZXhUb1JnYilcbiAgICAgICk7XG5cbiAgICAvLyBwb2ludCByYWRpdXNcbiAgICBjb25zdCByU2NhbGUgPVxuICAgICAgc2l6ZUZpZWxkICYmXG4gICAgICB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShzaXplU2NhbGUsIHNpemVEb21haW4sIHJhZGl1c1JhbmdlLCBmaXhlZFJhZGl1cyk7XG5cbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oY29sdW1ucyk7XG5cbiAgICBpZiAoIW9sZExheWVyRGF0YSB8fCBvbGRMYXllckRhdGEuZ2V0UG9zaXRpb24gIT09IGdldFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyTWV0YShhbGxEYXRhLCBnZXRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKFxuICAgICAgb2xkTGF5ZXJEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEuZGF0YSAmJlxuICAgICAgb3B0LnNhbWVEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEuZ2V0UG9zaXRpb24gPT09IGdldFBvc2l0aW9uXG4gICAgKSB7XG4gICAgICBkYXRhID0gb2xkTGF5ZXJEYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBmaWx0ZXJlZEluZGV4LnJlZHVjZSgoYWNjdSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2RhdGE6IGFsbERhdGFbaW5kZXhdfSk7XG5cbiAgICAgICAgLy8gaWYgZG9lc24ndCBoYXZlIHBvaW50IGxhdCBvciBsbmcsIGRvIG5vdCBhZGQgdGhlIHBvaW50XG4gICAgICAgIC8vIGRlY2suZ2wgY2FuJ3QgaGFuZGxlIHBvc2l0aW9uID0gbnVsbFxuICAgICAgICBpZiAoIXBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY3U7XG4gICAgICAgIH1cblxuICAgICAgICBhY2N1LnB1c2goe1xuICAgICAgICAgIGRhdGE6IGFsbERhdGFbaW5kZXhdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhY2N1O1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFJhZGl1cyA9IHJTY2FsZSA/IGQgPT5cbiAgICAgIHRoaXMuZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZShyU2NhbGUsIGQuZGF0YSwgc2l6ZUZpZWxkKSA6IDE7XG5cbiAgICBjb25zdCBnZXRDb2xvciA9IGNTY2FsZSA/IGQgPT5cbiAgICAgIHRoaXMuZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZShjU2NhbGUsIGQuZGF0YSwgY29sb3JGaWVsZCkgOiBjb2xvcjtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZ2V0UG9zaXRpb24sXG4gICAgICBnZXRDb2xvcixcbiAgICAgIGdldFJhZGl1c1xuICAgIH07XG4gIH1cblxuICB1cGRhdGVMYXllck1ldGEoYWxsRGF0YSwgZ2V0UG9zaXRpb24pIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldFBvaW50c0JvdW5kcyhhbGxEYXRhLCBkID0+IGdldFBvc2l0aW9uKHtkYXRhOiBkfSkpO1xuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICByZW5kZXJMYXllcih7XG4gICAgZGF0YSxcbiAgICBpZHgsXG4gICAgbGF5ZXJJbnRlcmFjdGlvbixcbiAgICBvYmplY3RIb3ZlcmVkLFxuICAgIG1hcFN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnXG4gIH0pIHtcbiAgICBjb25zdCBlbmFibGVCcnVzaGluZyA9IGludGVyYWN0aW9uQ29uZmlnLmJydXNoLmVuYWJsZWQ7XG5cbiAgICBjb25zdCBsYXllclByb3BzID0ge1xuICAgICAgb3V0bGluZTogdGhpcy5jb25maWcudmlzQ29uZmlnLm91dGxpbmUsXG4gICAgICByYWRpdXNNaW5QaXhlbHM6IDEsXG4gICAgICBmcDY0OiB0aGlzLmNvbmZpZy52aXNDb25maWdbJ2hpLXByZWNpc2lvbiddLFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy50aGlja25lc3MsXG4gICAgICByYWRpdXNTY2FsZTogdGhpcy5nZXRSYWRpdXNTY2FsZUJ5Wm9vbShtYXBTdGF0ZSksXG4gICAgICAuLi4odGhpcy5jb25maWcudmlzQ29uZmlnLmZpeGVkUmFkaXVzID8ge30gOiB7cmFkaXVzTWF4UGl4ZWxzOiA1MDB9KVxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcmFjdGlvbiA9IHtcbiAgICAgIGF1dG9IaWdobGlnaHQ6ICFlbmFibGVCcnVzaGluZyxcbiAgICAgIGVuYWJsZUJydXNoaW5nLFxuICAgICAgYnJ1c2hSYWRpdXM6IGludGVyYWN0aW9uQ29uZmlnLmJydXNoLmNvbmZpZy5zaXplICogMTAwMCxcbiAgICAgIGhpZ2hsaWdodENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvclxuICAgIH07XG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFNjYXR0ZXJwbG90QnJ1c2hpbmdMYXllcih7XG4gICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgIC4uLmxheWVySW50ZXJhY3Rpb24sXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIC4uLmludGVyYWN0aW9uLFxuICAgICAgICBpZHgsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLmNvbmZpZy52aXNDb25maWcub3BhY2l0eSxcbiAgICAgICAgcGlja2FibGU6IHRydWUsXG4gICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAvLyBjaXJjbGVzIHdpbGwgYmUgZmxhdCBvbiB0aGUgbWFwIHdoZW4gdGhlIGFsdGl0dWRlIGNvbHVtbiBpcyBub3QgdXNlZFxuICAgICAgICAgIGRlcHRoVGVzdDogdGhpcy5jb25maWcuY29sdW1ucy5hbHRpdHVkZS5maWVsZElkeCA+IC0xXG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRSYWRpdXM6IHtcbiAgICAgICAgICAgIHNpemVGaWVsZDogdGhpcy5jb25maWcuc2l6ZUZpZWxkLFxuICAgICAgICAgICAgcmFkaXVzUmFuZ2U6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5yYWRpdXNSYW5nZSxcbiAgICAgICAgICAgIGZpeGVkUmFkaXVzOiB0aGlzLmNvbmZpZy52aXNDb25maWcuZml4ZWRSYWRpdXMsXG4gICAgICAgICAgICBzaXplU2NhbGU6IHRoaXMuY29uZmlnLnNpemVTY2FsZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q29sb3I6IHtcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbmZpZy5jb2xvcixcbiAgICAgICAgICAgIGNvbG9yRmllbGQ6IHRoaXMuY29uZmlnLmNvbG9yRmllbGQsXG4gICAgICAgICAgICBjb2xvclJhbmdlOiB0aGlzLmNvbmZpZy52aXNDb25maWcuY29sb3JSYW5nZSxcbiAgICAgICAgICAgIGNvbG9yU2NhbGU6IHRoaXMuY29uZmlnLmNvbG9yU2NhbGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgLy8gdGV4dCBsYWJlbCBsYXllclxuICAgICAgLi4uKHRoaXMuY29uZmlnLnRleHRMYWJlbC5maWVsZFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIG5ldyBUZXh0TGF5ZXIoe1xuICAgICAgICAgICAgICBpZDogYCR7dGhpcy5pZH0tbGFiZWxgLFxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLmRhdGEsXG4gICAgICAgICAgICAgIGdldFBvc2l0aW9uOiBkYXRhLmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgICBnZXRQaXhlbE9mZnNldDogdGhpcy5jb25maWcudGV4dExhYmVsLm9mZnNldCxcbiAgICAgICAgICAgICAgZ2V0U2l6ZTogdGhpcy5jb25maWcudGV4dExhYmVsLnNpemUsXG4gICAgICAgICAgICAgIGdldFRleHRBbmNob3I6IHRoaXMuY29uZmlnLnRleHRMYWJlbC5hbmNob3IsXG4gICAgICAgICAgICAgIGdldFRleHQ6IGQgPT4gU3RyaW5nKGQuZGF0YVt0aGlzLmNvbmZpZy50ZXh0TGFiZWwuZmllbGQudGFibGVGaWVsZEluZGV4IC0gMV0pLFxuICAgICAgICAgICAgICBnZXRDb2xvcjogZCA9PiB0aGlzLmNvbmZpZy50ZXh0TGFiZWwuY29sb3IsXG4gICAgICAgICAgICAgIGZwNjQ6IHRoaXMuY29uZmlnLnZpc0NvbmZpZ1snaGktcHJlY2lzaW9uJ10sXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IHdpbGwgYWx3YXlzIHNob3cgb24gdG9wIG9mIGFsbCBsYXllcnNcbiAgICAgICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zaXRpb246IGRhdGEuZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZ2V0UGl4ZWxPZmZzZXQ6IHRoaXMuY29uZmlnLnRleHRMYWJlbC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZ2V0VGV4dDogdGhpcy5jb25maWcudGV4dExhYmVsLmZpZWxkLFxuICAgICAgICAgICAgICAgIGdldFRleHRBbmNob3I6IHRoaXMuY29uZmlnLnRleHRMYWJlbC5hbmNob3IsXG4gICAgICAgICAgICAgICAgZ2V0U2l6ZTogdGhpcy5jb25maWcudGV4dExhYmVsLnNpemUsXG4gICAgICAgICAgICAgICAgZ2V0Q29sb3I6IHRoaXMuY29uZmlnLnRleHRMYWJlbC5jb2xvclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF1cbiAgICAgICAgOiBbXSlcbiAgICBdO1xuICB9XG59XG4iXX0=